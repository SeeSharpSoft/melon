package net.seesharpsoft.melon.jdbc;

import net.seesharpsoft.commons.jdbc.PreparedStatementWrapper;
import net.seesharpsoft.melon.Melon;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;

public class MelonPreparedStatement extends PreparedStatementWrapper {

    protected Melon melon;

    public MelonPreparedStatement(Melon melon, Statement delegate) {
        super(delegate);
        this.melon = melon;
    }

    protected int[] checkSyncWithMelonade(int[] noOfResults) throws SQLException {
        Connection connection = this.getConnection();

        if (connection.getAutoCommit() && Arrays.stream(noOfResults).anyMatch(noOfResult -> noOfResult > 0)) {
            melon.syncToStorage(this.getConnection());
        }
        return noOfResults;
    }

    protected long[] checkSyncWithMelonade(long[] noOfResults) throws SQLException {
        Connection connection = this.getConnection();

        if (connection.getAutoCommit() && Arrays.stream(noOfResults).anyMatch(noOfResult -> noOfResult > 0)) {
            melon.syncToStorage(this.getConnection());
        }
        return noOfResults;
    }

    protected <T extends Number> T checkSyncWithMelonade(T noOfResults) throws SQLException {
        Connection connection = this.getConnection();

        if (connection.getAutoCommit() && noOfResults.longValue() > 0) {
            melon.syncToStorage(this.getConnection());
        }
        return noOfResults;
    }

    protected boolean checkSyncWithMelonade(boolean isResultSet) throws SQLException {
        Connection connection = this.getConnection();

        if (connection.getAutoCommit() && !isResultSet && getUpdateCount() > 0) {
            melon.syncToStorage(this.getConnection());
        }
        return isResultSet;
    }

    protected void updateDbIfNecessary() throws SQLException {
        melon.syncToDatabase(getConnection(), false);
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        this.updateDbIfNecessary();
        return super.executeQuery(sql);
    }

    @Override
    public ResultSet executeQuery() throws SQLException {
        this.updateDbIfNecessary();
        return super.executeQuery();
    }

    @Override
    public boolean execute() throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.execute());
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.execute(sql));
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.execute(sql, autoGeneratedKeys));
    }

    @Override
    public boolean execute(String sql, int columnIndexes[]) throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.execute(sql, columnIndexes));
    }

    @Override
    public boolean execute(String sql, String columnNames[]) throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.execute(sql, columnNames));
    }

    @Override
    public int[] executeBatch() throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.executeBatch());
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.executeUpdate(sql, columnNames));
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.executeUpdate(sql, columnIndexes));
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.executeUpdate(sql, autoGeneratedKeys));
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.executeUpdate(sql));
    }

    @Override
    public int executeUpdate() throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.executeUpdate());
    }

    @Override
    public long[] executeLargeBatch() throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.executeLargeBatch());
    }

    @Override
    public long executeLargeUpdate() throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.executeLargeUpdate());
    }

    @Override
    public long executeLargeUpdate(String sql) throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.executeLargeUpdate(sql));
    }

    @Override
    public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.executeLargeUpdate(sql, autoGeneratedKeys));
    }

    @Override
    public long executeLargeUpdate(String sql, int columnIndexes[]) throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.executeLargeUpdate(sql, columnIndexes));
    }

    @Override
    public long executeLargeUpdate(String sql, String columnNames[]) throws SQLException {
        this.updateDbIfNecessary();
        return checkSyncWithMelonade(super.executeLargeUpdate(sql, columnNames));
    }
}
